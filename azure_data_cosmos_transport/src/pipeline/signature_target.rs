// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

use base64::Engine;
use openssl::{hash::MessageDigest, pkey::PKey, sign::Signer};
use reqwest::Method;

use crate::resource_context::ResourceLink;

pub fn hmac_sha256(data: &str, key: &String) -> anyhow::Result<String> {
    let decoded = base64::engine::general_purpose::STANDARD.decode(key)?;
    let signature = {
        let pkey = PKey::hmac(&decoded)?;
        let mut signer = Signer::new(MessageDigest::sha256(), &pkey)?;
        signer.update(data.as_bytes())?;
        signer.sign_to_vec()
    }?;

    let encoded = base64::engine::general_purpose::STANDARD.encode(signature);
    Ok(encoded)
}

pub struct SignatureTarget<'a> {
    http_method: Method,
    link: &'a ResourceLink,
    date_string: &'a str,
}

impl<'a> SignatureTarget<'a> {
    pub fn new(http_method: Method, link: &'a ResourceLink, date_string: &'a str) -> Self {
        SignatureTarget {
            http_method,
            link,
            date_string,
        }
    }

    pub fn into_authorization(self, key: &String) -> anyhow::Result<String> {
        let string_to_sign = self.into_signable_string()?;
        // The signature payload is NOT SECRET. The signature IS SECRET, but we can safely log the signature payload (which can be useful for diagnosing auth errors)
        tracing::debug!(signature_payload = ?string_to_sign, "generating Cosmos auth signature");
        let signature = hmac_sha256(&string_to_sign, key)?;
        Ok(format!("type=master&ver=1.0&sig={signature}"))
    }

    /// This function generates a valid authorization string, according to the documentation.
    /// In case of authorization problems we can compare the `string_to_sign` generated by Azure against
    /// our own.
    fn into_signable_string(self) -> anyhow::Result<String> {
        // From official docs:
        // StringToSign =
        //      Verb.toLowerCase() + "\n" +
        //      ResourceType.toLowerCase() + "\n" +
        //      ResourceLink + "\n" +
        //      Date.toLowerCase() + "\n" +
        //      "" + "\n";
        // Notice the empty string at the end so we need to add two new lines

        Ok(format!(
            "{}\n{}\n{}\n{}\n\n",
            // Cosmos' signature algorithm requires lower-case methods, so we use our own match instead of the impl of AsRef<str>, which is uppercase.
            match self.http_method {
                reqwest::Method::GET => "get",
                reqwest::Method::PUT => "put",
                reqwest::Method::POST => "post",
                reqwest::Method::DELETE => "delete",
                reqwest::Method::HEAD => "head",
                reqwest::Method::TRACE => "trace",
                reqwest::Method::OPTIONS => "options",
                reqwest::Method::CONNECT => "connect",
                reqwest::Method::PATCH => "patch",
                _ => "extension",
            },
            self.link.resource_type().path_segment(),
            self.link.resource_link(),
            self.date_string,
        ))
    }
}

#[cfg(test)]
mod tests {
    use crate::{
        pipeline::{parse_rfc3339, signature_target::SignatureTarget, to_rfc7231},
        resource_context::{ResourceLink, ResourceType},
    };

    // We test the full authorization header in authorization_policy.
    // However, testing the signable string here is useful to isolate failures in constructing the string to be signed
    #[test]
    fn into_signable_string_generates_correct_value() {
        let time_nonce = parse_rfc3339("1900-01-01T01:00:00.000000000+00:00").unwrap();
        let date_string = to_rfc7231(&time_nonce);

        let ret = SignatureTarget::new(
            reqwest::Method::GET,
            &ResourceLink::root(ResourceType::Databases)
                .item("MyDatabase")
                .feed(ResourceType::Containers)
                .item("MyCollection"),
            &date_string,
        )
        .into_signable_string()
        .unwrap();
        assert_eq!(
            ret,
            "get
colls
dbs/MyDatabase/colls/MyCollection
mon, 01 jan 1900 01:00:00 gmt

"
        );
    }
}
